# movie_app

### Implementation of Clean Architecture, SOLID Principles, and Dependency Injection

#### Clean Architecture
In this project, I adhered to the principles of Clean Architecture by separating the application into distinct layers, each with its own responsibilities:

1. **Presentation Layer**: This layer includes the UI components and the logic to handle user input. I used `flutter_bloc` for state management, which allows the separation of business logic from the UI. The UI components interact with the bloc/cubit to get data and handle user actions.

2. **Domain Layer**: The domain layer is the core of the application. It contains the business logic and use cases. This layer is completely independent of any other layers and external libraries. The use cases define the application's business rules, and entities encapsulate the core data.

3. **Data Layer**: The data layer is responsible for handling data operations, such as fetching data from remote APIs or local databases. I used the `dio` and `retrofit` packages for making API requests and mapping JSON responses to Dart models. The `json_serializable` package was used to generate code for serializing JSON data. Repositories in this layer implement the abstract repositories defined in the domain layer, ensuring that the data layer is independent of the underlying data source.

#### SOLID Principles
I followed SOLID principles to ensure that the code is modular, maintainable, and easy to extend:

1. **Single Responsibility Principle (SRP)**: Each class has a single responsibility. For instance, the bloc handles state management, while repositories handle data fetching. This separation of concerns makes the code easier to maintain and test.

2. **Open/Closed Principle (OCP)**: The code is designed to be open for extension but closed for modification. By using interfaces and abstract classes, new functionalities can be added without modifying existing code. For example, new data sources can be introduced by implementing the repository interface without altering the existing repositories.

3. **Liskov Substitution Principle (LSP)**: Derived classes or interfaces can be substituted for their base classes without affecting the correctness of the program. The repositories in the data layer can be replaced with mock implementations during testing without impacting the application flow.

4. **Interface Segregation Principle (ISP)**: Interfaces are designed to be small and specific to client needs. This ensures that classes implementing the interfaces do not need to implement methods they do not use. In this project, I used abstract classes to define specific contracts for repositories and services.

5. **Dependency Inversion Principle (DIP)**: High-level modules do not depend on low-level modules; both depend on abstractions. The project uses dependency injection to provide dependencies through constructors or service locators, decoupling the implementation from the classes that depend on them.

#### Dependency Injection
To implement dependency injection, I used the `get_it` and `injectable` packages:

1. **Service Locator**: The `get_it` package serves as a service locator, managing the dependencies throughout the application. It allows the decoupling of class dependencies, making the code easier to manage and test.

2. **Code Generation**: The `injectable` package is used to generate the necessary boilerplate code for dependency injection. By annotating classes with `@injectable` and configuring the dependency injection setup in a dedicated file, dependencies are automatically injected wherever needed.

3. **Setup**: In the project's `main.dart`, I initialize the dependency injection setup by calling the `configureDependencies` function, which is generated by the `injectable` package. This setup ensures that all necessary dependencies are available throughout the application.

### Dependencies and Tools Used
- **State Management**: `flutter_bloc` for managing the state in a clean and scalable manner.
- **Networking**: `dio` and `retrofit` for making network requests and handling API interactions.
- **Dependency Injection**: `get_it` and `injectable` for managing dependencies and ensuring a clean architecture.
- **JSON Handling**: `json_annotation` and `json_serializable` for serializing and deserializing JSON data.

By following Clean Architecture and SOLID principles, the project is structured to be maintainable, scalable, and testable, with clear separation of concerns and minimal coupling between different layers. Dependency injection ensures that the application components are loosely coupled and can be easily replaced or mocked during testing.
####Instructions:
flutter pub get 
flutter run
